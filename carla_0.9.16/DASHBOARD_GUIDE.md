# Model Interpretability Dashboard 使用指南

## 概述

Model Interpretability Dashboard v3.0 是一个 2560x1440 分辨率（2K）的实时可视化仪表板，用于分析和解释自动驾驶模型的决策过程。该仪表板集成了多种学术界认可的可解释性分析方法，帮助研究人员理解模型在不同场景下的行为。

### 核心特性

- **实时分析**：每帧执行完整的可解释性分析，无需等待
- **多方法融合**：结合定性（热力图）和定量（数值指标）分析方法
- **学术严谨**：所有方法均有学术论文支撑，可直接用于论文撰写
- **多分支支持**：支持同时查看4个导航分支的预测结果
- **优化布局**：v3.0 重新设计了布局，避免面板重叠，提升可读性

### 设计理念

仪表板设计遵循以下原则：
1. **信息密度最大化**：在2560x1440分辨率下展示尽可能多的有用信息
2. **视觉层次清晰**：通过颜色编码和空间布局区分不同类型的信息
3. **实时性优先**：所有分析方法都经过优化，确保实时运行
4. **学术可用性**：提供可直接用于论文的定量指标
5. **避免重叠**：v3.0 优化了布局计算，确保所有面板不重叠

![Dashboard Overview](dashboard_example.png)

---

## 仪表板布局 (v3.0)

仪表板分为以下几个主要区域（2560x1440 分辨率）：

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                              标题栏 (Header) - 55px                                       │
├─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────────────────────────┤
│  Input  │ Brake   │Throttle │ Steer   │Occlusion│ Integr. │ Layer Info                  │
│(88x200) │ CAM++   │ CAM++   │ CAM++   │Sensitiv.│Gradients│                             │
├─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────────────────────────┤
│ Brake L1│Brake L2 │Brake L3 │Brake L4 │Brake L5 │Brake L6 │Brake L7 │Brake L8 │Fused   │
├─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┤
│ Throt L1│Throt L2 │Throt L3 │Throt L4 │Throt L5 │Throt L6 │Throt L7 │Throt L8 │Fused   │
├─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┤
│ Steer L1│Steer L2 │Steer L3 │Steer L4 │Steer L5 │Steer L6 │Steer L7 │Steer L8 │Fused   │
├─────────────────────┬───────────────────────┬───────────────────────┬───────────────────┤
│   Control Output    │ Quantitative Metrics  │ All Branches          │ Traffic Light    │
│   (Current Branch)  │ (Academic)            │ Comparison            │ Status           │
├─────────────────────┴───────────────────────┼───────────────────────┴───────────────────┤
│   Control History (All Frames)                  │ Deletion/Insertion  │ Brake Statistics   │
│                                                 │ Curves              │                    │
├─────────────────────────────────────────────────┴─────────────────────┴────────────────────┤
│                              底部信息栏 (Footer) - 45px                                     │
└─────────────────────────────────────────────────────────────────────────────────────────────┘
```

### 布局参数 (v3.0)

| 参数 | 值 | 说明 |
|------|-----|------|
| 总宽度 | 2560px | 2K分辨率 |
| 总高度 | 1440px | 2K分辨率 |
| Header高度 | 55px | 标题栏 |
| Footer高度 | 45px | 底部信息栏 |
| Row1高度 | 155px | 主图像行 |
| Row2-4高度 | 135px | 热力图行（每行） |
| Row5高度 | 195px | 控制面板行 |
| Row6高度 | 220px | 历史曲线行 |
| 面板间距 | 10px | 水平间距 |
| 行间距 | 8px | 垂直间距 |
| 边距 | 12px | 左右边距 |

---

## 各区域详细说明

### 1. 标题栏 (Header)

**位置**：顶部 (0-65px)

标题栏提供仪表板的基本信息和当前状态概览。

| 元素 | 位置 | 说明 |
|------|------|------|
| **主标题** | 左侧 | "Model Interpretability Dashboard v2.0" |
| **副标题** | 主标题右侧 | 显示分辨率(1920x1080)和使用的分析方法 |
| **Branch 标签** | 右侧高亮区域 | 当前激活的分支（Follow/Left/Right/Straight），用颜色区分 |
| **Frame 计数** | 最右侧 | 当前帧号，用于追踪分析进度 |

#### 分支颜色编码

分支颜色编码在整个仪表板中保持一致，便于快速识别：

| 分支 | 中文名 | BGR颜色值 (OpenCV) | 颜色描述 | 使用场景 |
|------|--------|-------------------|----------|----------|
| Follow (B0) | 跟车 | `(80, 200, 200)` | 黄色 | 跟随前车行驶，最常见的驾驶模式 |
| Left (B1) | 左转 | `(200, 200, 80)` | 青色 | 在路口执行左转操作 |
| Right (B2) | 右转 | `(200, 80, 200)` | 紫色 | 在路口执行右转操作 |
| Straight (B3) | 直行 | `(80, 200, 80)` | 绿色 | 在路口直行通过 |

> **注意**：颜色值使用 OpenCV 的 BGR 格式（蓝-绿-红），而非常见的 RGB 格式。
> - 黄色 = 低蓝 + 高绿 + 高红 = (80, 200, 200)
> - 青色 = 高蓝 + 高绿 + 低红 = (200, 200, 80)

#### 分支选择逻辑

分支由导航规划器根据当前路线自动选择：
- 导航命令编码：2=Follow, 3=Left, 4=Right, 5=Straight
- 分支索引 = 导航命令 - 2（即 B0-B3）
- 模型输出12个值（4分支 × 3控制），仪表板只显示当前激活分支的结果

---

### 2. 主图像行 (Main Image Row)

**位置**：第一行 (75-237px)

这一行展示6个并排的面板，从左到右依次为：原始输入、三个Grad-CAM++热力图、遮挡敏感性图、积分梯度图。

#### 2.1 Input (88x200)

**面板标题**：`Input (88x200)`

**内容说明**：
- 显示模型实际接收的输入图像
- 图像经过裁剪（去除天空和车头）和缩放处理
- 最终尺寸为 88×200 像素（高×宽）

**图像预处理流程**：
```
原始摄像头图像 (800×600)
    ↓ 裁剪 [90:485, :]
裁剪后图像 (395×800)
    ↓ 缩放
模型输入 (88×200)
```

**用途**：
- 确认模型"看到"的内容与预期一致
- 检查图像预处理是否正确
- 作为热力图叠加的基础图像

**技术细节**：
- 裁剪参数：`crop_top=90, crop_bottom=485`
- 去除天空区域可减少无关信息干扰
- 去除车头区域避免模型学习到固定模式

---

#### 2.2 Brake CAM++ (B0-B3)

**面板标题**：`Brake CAM++ (Bx)` （x为当前分支索引）

**内容说明**：
- 针对刹车输出的 Grad-CAM++ 热力图
- 显示模型在预测刹车值时关注的图像区域

**颜色映射**：JET 色图
| 颜色 | 含义 | 数值范围 |
|------|------|----------|
| 蓝色 | 低关注度 | 0.0 - 0.25 |
| 绿色 | 中低关注度 | 0.25 - 0.5 |
| 黄色 | 中高关注度 | 0.5 - 0.75 |
| 红色 | 高关注度 | 0.75 - 1.0 |

**叠加方式**：
- 原图权重：35%
- 热力图权重：65%
- 公式：`overlay = 0.35 × original + 0.65 × heatmap`

**Grad-CAM++ 算法原理**：

Grad-CAM++ 是 Grad-CAM 的改进版本，对多目标场景更准确。

1. **前向传播**：获取目标卷积层的特征图 $A^k$
2. **反向传播**：计算目标输出对特征图的梯度 $\frac{\partial y}{\partial A^k}$
3. **权重计算**（Grad-CAM++ 改进）：
   $$\alpha^k = \frac{(\frac{\partial y}{\partial A^k})^2}{2(\frac{\partial y}{\partial A^k})^2 + \sum_{i,j} A^k_{ij} \cdot (\frac{\partial y}{\partial A^k})^3}$$
4. **加权求和**：$L = ReLU(\sum_k \alpha^k \cdot A^k)$
5. **上采样**：将热力图缩放到原图尺寸 (88×200)

**参考文献**：
> Chattopadhay et al., "Grad-CAM++: Generalized Gradient-based Visual Explanations for Deep Convolutional Networks", WACV 2018

**典型解读**：
- 红色区域集中在前方车辆 → 模型正确关注障碍物
- 红色区域集中在道路边缘 → 模型可能在判断车道边界
- 红色区域分散 → 模型决策依据不明确，需要进一步分析

---

#### 2.3 Throttle CAM++ (B0-B3)

**面板标题**：`Throttle CAM++ (Bx)`

**内容说明**：
- 针对油门输出的 Grad-CAM++ 热力图
- 标题使用绿色，与油门控制条颜色一致

**与 Brake CAM++ 的区别**：
- 目标输出不同：`target_output='throttle'`
- 关注区域可能不同：油门决策可能更关注道路前方的开阔程度

**典型解读**：
- 红色区域在道路中央 → 模型识别到可通行区域
- 红色区域在远处 → 模型在评估前方道路状况
- 与 Brake CAM++ 重叠度高 → 模型使用相似特征做出互斥决策

---

#### 2.4 Steer CAM++ (B0-B3)

**面板标题**：`Steer CAM++ (Bx)`

**内容说明**：
- 针对转向输出的 Grad-CAM++ 热力图
- 标题使用黄色，与转向控制条颜色一致

**典型解读**：
- 红色区域在道路边缘 → 模型在判断车道位置
- 红色区域偏左/右 → 模型可能在准备转向
- 红色区域在道路标线上 → 模型正确识别车道标记

**转向决策的特殊性**：
- 转向是唯一有正负值的控制输出（-1.0 到 +1.0）
- 热力图显示的是绝对重要性，不区分左转/右转
- 需要结合实际转向值理解热力图含义

---

#### 2.5 Occlusion Sensitivity

**面板标题**：`Occlusion Sensitivity`

**内容说明**：
- 遮挡敏感性分析热力图
- 通过系统性遮挡图像区域，测量模型输出变化

**颜色映射**：HOT 色图
| 颜色 | 含义 | 敏感性 |
|------|------|--------|
| 黑色 | 极低敏感性 | 遮挡后输出几乎不变 |
| 红色 | 中等敏感性 | 遮挡后输出有明显变化 |
| 黄色 | 高敏感性 | 遮挡后输出显著变化 |
| 白色 | 极高敏感性 | 遮挡后输出剧烈变化 |

**算法原理**：

```
for each patch (y, x) in image:
    occluded_image = image.copy()
    occluded_image[y:y+patch_size, x:x+patch_size] = 0  # 遮挡
    output_change = |original_output - model(occluded_image)|
    sensitivity_map[y:y+patch_size, x:x+patch_size] += output_change
```

**参数设置**：
- `patch_size=2`：遮挡块大小（2×2像素，高精度分析）
- `stride=2`：滑动步长（2像素，无重叠）

**与 Grad-CAM++ 的区别**：

| 特性 | Grad-CAM++ | Occlusion Sensitivity |
|------|------------|----------------------|
| 计算方式 | 基于梯度 | 基于扰动 |
| 计算速度 | 快（单次前向+反向） | 慢（多次前向传播） |
| 结果类型 | 定性（相对重要性） | 定量（绝对敏感性） |
| 理论基础 | 梯度近似 | 直接测量 |

**参考文献**：
> Zeiler & Fergus, "Visualizing and Understanding Convolutional Networks", ECCV 2014

**用途**：
- 验证 Grad-CAM++ 结果的可靠性
- 获取定量的区域重要性度量
- 识别模型决策的关键区域

---

#### 2.6 Integrated Gradients

**面板标题**：`Integrated Gradients`

**内容说明**：
- 积分梯度归因图
- 一种满足公理化要求的严谨归因方法
- 被广泛认为是深度学习可解释性领域的"黄金标准"方法之一

**颜色映射**：VIRIDIS 色图
| 颜色 | 含义 | 归因值范围 |
|------|------|-----------|
| 深紫色 | 低归因值 | 0% - 20% |
| 蓝色 | 中低归因值 | 20% - 40% |
| 绿色 | 中等归因值 | 40% - 60% |
| 黄绿色 | 中高归因值 | 60% - 80% |
| 黄色 | 高归因值 | 80% - 100% |

**方法背景与动机**：

传统的梯度方法（如 Vanilla Gradient、Gradient × Input）存在以下问题：
- **梯度饱和问题**：当神经元处于饱和区域时，梯度接近零，无法正确反映特征重要性
- **不满足敏感性公理**：即使某个特征对输出有决定性影响，其梯度也可能为零
- **基线依赖不明确**：缺乏对"无信息输入"的明确定义

积分梯度通过沿路径积分的方式，优雅地解决了这些问题。

**算法原理**：

积分梯度沿从基线（黑色图像）到输入图像的路径积分梯度：

$$IG_i(x) = (x_i - x'_i) \times \int_{\alpha=0}^{1} \frac{\partial F(x' + \alpha(x-x'))}{\partial x_i} d\alpha$$

其中：
- $x$ 是输入图像（维度为 $H \times W \times C$）
- $x'$ 是基线（通常为全黑图像，代表"无信息"状态）
- $F$ 是模型输出（本系统中为转向角预测值）
- $\alpha \in [0, 1]$ 是插值参数，控制从基线到输入的过渡
- $i$ 表示第 $i$ 个像素/特征维度

**直观理解**：

```
基线 (x')          插值路径           输入 (x)
[全黑图像] ----α=0.0---α=0.5---α=1.0----> [实际图像]
     ↓                ↓                    ↓
   F(x')          F(中间态)              F(x)
```

积分梯度计算的是：当我们沿着这条路径从基线"走向"输入时，每个像素对模型输出变化的累积贡献。

**数值积分实现**：

由于解析积分通常不可行，实际使用黎曼和近似：

$$IG_i(x) \approx (x_i - x'_i) \times \sum_{k=1}^{m} \frac{\partial F(x' + \frac{k}{m}(x-x'))}{\partial x_i} \times \frac{1}{m}$$

其中 $m$ 为积分步数。

**实现细节**：

| 参数 | 值 | 说明 |
|------|-----|------|
| `steps` | 30 | 积分步数（黎曼和近似） |
| 基线类型 | 全零张量 | 黑色图像，代表无信息输入 |
| 积分方法 | 梯形积分 | 比简单黎曼和更精确 |
| 通道聚合 | 绝对值求和 | $\|IG_R\| + \|IG_G\| + \|IG_B\|$ |
| 归一化 | Min-Max | 映射到 [0, 1] 用于可视化 |

**代码实现示意**：

```python
def integrated_gradients(model, input_image, baseline=None, steps=30):
    """
    计算积分梯度归因图
    
    Args:
        model: 神经网络模型
        input_image: 输入图像 [1, C, H, W]
        baseline: 基线图像，默认为全黑
        steps: 积分步数
    
    Returns:
        attributions: 归因图 [H, W]
    """
    if baseline is None:
        baseline = torch.zeros_like(input_image)
    
    # 生成插值路径
    scaled_inputs = [baseline + (float(i) / steps) * (input_image - baseline) 
                     for i in range(1, steps + 1)]
    
    # 计算每个插值点的梯度
    gradients = []
    for scaled_input in scaled_inputs:
        scaled_input.requires_grad_(True)
        output = model(scaled_input)
        output.backward()
        gradients.append(scaled_input.grad.clone())
    
    # 梯形积分近似
    avg_gradients = torch.mean(torch.stack(gradients), dim=0)
    
    # 积分梯度 = (输入 - 基线) × 平均梯度
    integrated_grads = (input_image - baseline) * avg_gradients
    
    # 通道聚合：取绝对值后求和
    attributions = torch.sum(torch.abs(integrated_grads), dim=1).squeeze()
    
    return attributions
```

**公理化特性**：

积分梯度满足以下重要公理，这是其理论优越性的核心：

1. **完整性 (Completeness / Summation-to-Delta)**
   
   所有像素归因值之和等于输出差值：
   $$\sum_i IG_i(x) = F(x) - F(x')$$
   
   *意义*：归因值完整解释了模型预测与基线预测之间的差异，没有"遗漏"或"多余"的归因。

2. **敏感性 (Sensitivity)**
   
   如果输入 $x$ 和基线 $x'$ 仅在第 $i$ 个特征上不同，且 $F(x) \neq F(x')$，则 $IG_i(x) \neq 0$。
   
   *意义*：确保对输出有影响的特征一定会被归因，不会出现"漏检"。

3. **实现不变性 (Implementation Invariance)**
   
   如果两个网络在所有输入上产生相同输出，则它们的积分梯度归因相同。
   
   *意义*：归因只依赖于模型的输入-输出行为，而非内部实现细节。

4. **线性性 (Linearity)**
   
   如果模型 $F = a \cdot F_1 + b \cdot F_2$，则：
   $$IG(F) = a \cdot IG(F_1) + b \cdot IG(F_2)$$
   
   *意义*：对于组合模型，归因可以线性分解。

5. **对称性 (Symmetry)**
   
   如果两个特征在模型中扮演对称角色，且在输入和基线中取值相同，则它们的归因相等。

**与其他归因方法的对比**：

| 方法 | 完整性 | 敏感性 | 实现不变性 | 计算成本 | 噪声水平 |
|------|--------|--------|------------|----------|----------|
| Vanilla Gradient | ✗ | ✗ | ✓ | 低 | 高 |
| Gradient × Input | ✗ | ✗ | ✓ | 低 | 中 |
| SmoothGrad | ✗ | ✗ | ✓ | 中 | 低 |
| **Integrated Gradients** | **✓** | **✓** | **✓** | **中** | **低** |
| SHAP (DeepLIFT) | ✓ | ✓ | ✗ | 高 | 低 |
| Occlusion | ✗ | ✓ | ✓ | 很高 | 中 |

**基线选择的影响**：

基线的选择对归因结果有重要影响：

| 基线类型 | 描述 | 适用场景 | 优缺点 |
|----------|------|----------|--------|
| 黑色图像 | 全零张量 | 通用场景（本系统采用） | 简单直观，但可能不代表"无信息" |
| 白色图像 | 全255张量 | 暗背景图像 | 适合特定场景 |
| 模糊图像 | 高斯模糊后的输入 | 保留结构信息 | 更自然的基线 |
| 随机噪声 | 均匀/高斯噪声 | 需要多次采样平均 | 减少基线偏差 |
| 数据集均值 | 训练集平均图像 | 统计意义上的"中性"输入 | 需要预计算 |

**在自动驾驶场景中的解读**：

| 高亮区域 | 可能含义 | 驾驶决策关联 |
|----------|----------|--------------|
| 道路边缘 | 车道边界检测 | 保持车道、转向角计算 |
| 前方车辆 | 跟车距离判断 | 速度调整、避障 |
| 交通标志/信号灯 | 规则识别 | 停车、让行决策 |
| 道路曲率 | 弯道检测 | 预判转向角度 |
| 阴影/光照变化 | 环境感知 | 可能是噪声或真实特征 |

**收敛性与步数选择**：

积分步数 $m$ 的选择影响精度和计算成本：

```
步数 (m)    相对误差    计算时间（相对）
   10        ~5%           1x
   30        ~1%           3x  ← 本系统采用
   50        ~0.5%         5x
  100        ~0.2%        10x
```

**收敛性验证**：可通过检查完整性公理来验证步数是否足够：
$$\epsilon = |F(x) - F(x') - \sum_i IG_i(x)|$$

当 $\epsilon$ 足够小时，说明积分近似已收敛。

**局限性与注意事项**：

1. **计算成本**：需要 $m$ 次前向和反向传播，比单次梯度计算慢约 $m$ 倍
2. **基线敏感性**：不同基线可能产生不同归因结果
3. **路径依赖**：理论上可以选择不同的积分路径（直线路径是最常用的）
4. **高维输入**：对于高分辨率图像，归因图可能较为稀疏

**参考文献**：

> [1] Sundararajan, M., Taly, A., & Yan, Q. (2017). "Axiomatic Attribution for Deep Networks". *ICML 2017*.
> 
> [2] Ancona, M., et al. (2018). "Towards better understanding of gradient-based attribution methods for Deep Neural Networks". *ICLR 2018*.
> 
> [3] Sturmfels, P., Lundberg, S., & Lee, S. I. (2020). "Visualizing the Impact of Feature Attribution Baselines". *Distill*.

**用途**：
- 提供理论上严谨的特征重要性分析
- 验证其他归因方法的准确性
- 用于学术论文中的可解释性分析
- 调试模型行为，发现潜在的偏差或错误关注点
- 满足监管要求的模型可解释性报告
- 与领域专家沟通模型决策依据

**调试技巧**：

1. **检查完整性**：如果归因值之和与输出差值相差较大，增加积分步数
2. **对比基线**：尝试不同基线，观察归因是否稳定
3. **关注异常**：如果模型关注了不相关区域（如天空），可能存在数据偏差
4. **结合其他方法**：与 GradCAM、Occlusion 等方法交叉验证

---

### 3. 多层级热力图行 (Multi-Layer Row)

**位置**：第二行 (245-390px)

这一行展示不同卷积层的 Grad-CAM++ 热力图，帮助理解模型在不同抽象层级的关注区域。

#### 3.1 为什么需要多层级分析？

卷积神经网络的不同层捕获不同级别的特征：

| 层级 | 特征类型 | 分辨率 | 语义信息 |
|------|----------|--------|----------|
| 浅层 (Layer 4) | 边缘、纹理 | 高 (17×45) | 低 |
| 中层 (Layer 6) | 形状、部件 | 中 (6×20) | 中 |
| 深层 (Layer 8) | 物体、场景 | 低 (2×16) | 高 |

#### 3.2 Brake Layer 8 (2×16)

**面板标题**：`Brake Layer 8 (2x16)`

**内容说明**：
- 最后一层卷积层（第8层）的 Grad-CAM++ 热力图
- 特征图尺寸：2×16（高×宽）
- 通道数：取决于网络结构

**特点**：
- 分辨率最低，但语义信息最丰富
- 每个像素对应原图较大区域
- 适合识别"模型关注什么物体"

**典型解读**：
- 热点集中在1-2个位置 → 模型关注特定物体
- 热点分散 → 模型综合多个因素决策

---

#### 3.3 Brake Layer 6 (6×20)

**面板标题**：`Brake Layer 6 (6x20)`

**内容说明**：
- 倒数第3层卷积层（第6层）的 Grad-CAM++ 热力图
- 特征图尺寸：6×20
- **推荐的默认分析层**

**特点**：
- 平衡语义信息和空间分辨率
- 热力图细节适中，易于解读
- 通常能提供最有意义的可视化结果

**为什么推荐 Layer 6**：
1. 分辨率足够高，能定位到具体区域
2. 语义信息足够丰富，能识别有意义的特征
3. 计算开销适中

---

#### 3.4 Brake Layer 4 (17×45)

**面板标题**：`Brake Layer 4 (17x45)`

**内容说明**：
- 倒数第5层卷积层（第4层）的 Grad-CAM++ 热力图
- 特征图尺寸：17×45
- 分辨率最高的分析层

**特点**：
- 保留更多空间细节
- 可能包含更多噪声
- 适合分析精细的空间关注模式

**典型解读**：
- 热点沿道路边缘分布 → 模型关注车道边界
- 热点呈条纹状 → 模型可能关注道路标线
- 热点分散且无规律 → 该层可能不是决策关键层

---

#### 3.5 Fused Multi-Layer

**面板标题**：`Fused Multi-Layer`

**内容说明**：
- 多层热力图的融合结果
- 综合多个层级的信息

**融合算法**：
```python
fused_cam = (cam_layer4 + cam_layer6 + cam_layer8) / 3
fused_cam = normalize(fused_cam)  # 归一化到 [0, 1]
```

**用途**：
- 获得更稳定的关注区域估计
- 减少单层分析的偏差
- 提供综合性的可视化结果

**解读建议**：
- 融合图与单层图一致 → 模型决策依据明确
- 融合图与单层图差异大 → 不同层关注不同特征，需要分层分析

---

#### 3.6 Layer Resolution Info

**面板标题**：`Layer Resolution Info`

**内容说明**：
显示当前目标层的详细技术信息。

**显示项目**：

| 项目 | 说明 | 示例值 |
|------|------|--------|
| Target Layer | 目标层索引/总层数 | -3/8 |
| Feature Map | 特征图尺寸 (H×W) | (6, 20) |
| Channels | 特征图通道数 | 256 |
| Method | 使用的方法 | Grad-CAM++ (improved) |

**技术细节**：
- 层索引使用负数表示从后往前数
- `-1` = 最后一层，`-3` = 倒数第3层
- 通道数影响热力图的计算复杂度

---

### 4. 控制输出面板 (Control Output Panel)

**位置**：左侧中部 (410-610px)，尺寸 450×200

**面板标题**：`Control Output (Current Branch)`

该面板显示当前激活分支的三个控制输出值。

#### 控制输出详解

| 控制项 | 颜色 | 范围 | 单位 | 说明 |
|--------|------|------|------|------|
| **Brake** | 红色 | 0.0-1.0 | 无量纲 | 刹车强度，0=不刹车，1=全力刹车 |
| **Throttle** | 绿色 | 0.0-1.0 | 无量纲 | 油门强度，0=不加速，1=全力加速 |
| **Steer** | 黄色 | -1.0 到 +1.0 | 无量纲 | 转向角度，负=左转，正=右转，0=直行 |

#### 可视化方式

**Brake/Throttle 进度条**：
```
┌────────────────────────────────────┐
│████████████░░░░░░░░░░░░░░░░░░░░░░░│ Brake: 0.350
└────────────────────────────────────┘
  ← 0.0                         1.0 →
```

**Steer 双向条**：
```
┌────────────────────────────────────┐
│░░░░░░░░░░░░░░░░░│████████░░░░░░░░░│ Steer: +0.250
└────────────────────────────────────┘
  ← -1.0 (左转)    0.0    +1.0 (右转) →
                    ↑
                  中线
```

#### 控制值解读

**Brake（刹车）**：
| 值范围 | 含义 | 典型场景 |
|--------|------|----------|
| 0.0 - 0.1 | 无刹车/轻微刹车 | 正常行驶 |
| 0.1 - 0.3 | 轻度刹车 | 减速、跟车 |
| 0.3 - 0.5 | 中度刹车 | 接近停止线 |
| 0.5 - 0.8 | 重度刹车 | 紧急减速 |
| 0.8 - 1.0 | 急刹车 | 紧急避障 |

**Throttle（油门）**：
| 值范围 | 含义 | 典型场景 |
|--------|------|----------|
| 0.0 - 0.2 | 低油门 | 缓慢起步、滑行 |
| 0.2 - 0.5 | 中等油门 | 正常加速 |
| 0.5 - 0.8 | 高油门 | 快速加速 |
| 0.8 - 1.0 | 全油门 | 急加速（少见） |

**Steer（转向）**：
| 值范围 | 含义 | 典型场景 |
|--------|------|----------|
| -1.0 到 -0.5 | 大幅左转 | 急转弯 |
| -0.5 到 -0.1 | 轻微左转 | 车道保持、缓弯 |
| -0.1 到 +0.1 | 直行 | 直线道路 |
| +0.1 到 +0.5 | 轻微右转 | 车道保持、缓弯 |
| +0.5 到 +1.0 | 大幅右转 | 急转弯 |

#### 油门与刹车的互斥关系

在正常驾驶中，油门和刹车通常是互斥的：
- 刹车 > 0.1 时，油门通常接近 0
- 油门 > 0.3 时，刹车通常为 0
- 两者同时较高可能表示模型决策异常

---

### 5. 定量指标面板 (Quantitative Metrics Panel)

**位置**：中部 (410-610px)，尺寸 550×200

**面板标题**：`Quantitative Metrics (Academic)`

该面板显示可用于学术论文的定量可解释性指标。

#### 指标详解

##### 5.1 Occlusion Sensitivity（遮挡敏感性）

**定义**：遮挡敏感性均值，表示模型对输入变化的平均敏感程度。

**计算公式**：
$$\text{Mean Sensitivity} = \frac{1}{N} \sum_{i=1}^{N} |f(x) - f(x_{\text{occluded}_i})|$$

其中 $N$ 是遮挡位置数量，$f(x)$ 是原始输出，$f(x_{\text{occluded}_i})$ 是遮挡第 $i$ 个区域后的输出。

**解读**：
| 值范围 | 含义 |
|--------|------|
| < 0.01 | 模型对输入变化不敏感，可能欠拟合 |
| 0.01 - 0.05 | 正常敏感度 |
| 0.05 - 0.1 | 较高敏感度，模型依赖局部特征 |
| > 0.1 | 极高敏感度，可能过度依赖某些区域 |

---

##### 5.2 IG Completeness Error（积分梯度完整性误差）

**定义**：积分梯度归因值之和与实际输出差值之间的误差。

**计算公式**：
$$\text{Completeness Error} = \left| \sum_i IG_i(x) - (F(x) - F(x')) \right|$$

**理论背景**：
根据积分梯度的完整性公理，归因值之和应该等于输出差值。误差越小，说明积分梯度计算越准确。

**解读**：
| 值范围 | 含义 |
|--------|------|
| < 0.001 | 极好，积分梯度计算非常准确 |
| 0.001 - 0.01 | 良好，可接受的误差范围 |
| 0.01 - 0.1 | 一般，可能需要增加积分步数 |
| > 0.1 | 较差，积分梯度结果可能不可靠 |

**改善方法**：
- 增加积分步数（`ig_steps` 参数）
- 使用更合适的基线图像
- 检查模型是否有数值不稳定问题

---

##### 5.3 Deletion AUC（删除曲线下面积）

**定义**：按重要性从高到低删除像素，观察模型输出下降的曲线下面积。

**计算过程**：
1. 根据显著性图对像素按重要性排序
2. 逐步删除最重要的像素（设为0）
3. 记录每步的模型输出
4. 计算曲线下面积（使用梯形积分）

**理想行为**：
- 如果显著性图准确识别了重要区域
- 删除这些区域应该导致输出快速下降
- 因此 **Deletion AUC 越低越好**

**解读**：
| 值范围 | 含义 |
|--------|------|
| < 0.2 | 极好，显著性图准确识别了关键区域 |
| 0.2 - 0.4 | 良好 |
| 0.4 - 0.6 | 一般 |
| > 0.6 | 较差，显著性图可能不准确 |

---

##### 5.4 Insertion AUC（插入曲线下面积）

**定义**：从空白图像开始，按重要性从高到低插入像素，观察模型输出上升的曲线下面积。

**计算过程**：
1. 从全黑基线图像开始
2. 根据显著性图按重要性顺序插入原图像素
3. 记录每步的模型输出
4. 计算曲线下面积

**理想行为**：
- 如果显著性图准确识别了重要区域
- 插入这些区域应该导致输出快速上升
- 因此 **Insertion AUC 越高越好**

**解读**：
| 值范围 | 含义 |
|--------|------|
| > 0.8 | 极好，显著性图准确识别了关键区域 |
| 0.6 - 0.8 | 良好 |
| 0.4 - 0.6 | 一般 |
| < 0.4 | 较差，显著性图可能不准确 |

---

##### 5.5 Combined Score（综合得分）

**定义**：
$$\text{Combined Score} = \text{Insertion AUC} - \text{Deletion AUC}$$

**解读**：
| 值范围 | 含义 |
|--------|------|
| > 0.5 | 极好，可解释性方法非常准确 |
| 0.3 - 0.5 | 良好 |
| 0.1 - 0.3 | 一般 |
| 0 - 0.1 | 较差 |
| < 0 | 很差，可解释性方法可能失效 |

**参考文献**：
> Petsiuk et al., "RISE: Randomized Input Sampling for Explanation of Black-box Models", BMVC 2018

---

#### 指标在学术论文中的使用

这些指标可以直接用于学术论文的定量评估：

```latex
\begin{table}[h]
\centering
\caption{Model Interpretability Quantitative Metrics}
\begin{tabular}{lcc}
\hline
\textbf{Metric} & \textbf{Mean} & \textbf{Std} \\
\hline
Occlusion Sensitivity & 0.0234 & 0.0089 \\
IG Completeness Error & 0.0012 & 0.0005 \\
Deletion AUC $\downarrow$ & 0.2156 & 0.0432 \\
Insertion AUC $\uparrow$ & 0.7823 & 0.0567 \\
Combined Score $\uparrow$ & 0.5667 & 0.0789 \\
\hline
\end{tabular}
\end{table}
```

---

### 6. 分支对比面板 (All Branches Comparison)

**位置**：右侧中部 (410-610px)，尺寸 450×200

**面板标题**：`All Branches Comparison`

该面板显示所有4个分支的预测输出，便于对比分析。

#### 显示格式

```
>> Follow    S:+0.02  T:0.65  B:0.00   ← 当前激活分支（高亮显示）
   Left      S:-0.15  T:0.58  B:0.02
   Right     S:+0.18  T:0.55  B:0.01
   Straight  S:+0.01  T:0.62  B:0.00
```

#### 列说明

| 列 | 全称 | 范围 | 说明 |
|----|------|------|------|
| **>>** | 标记 | - | 当前激活分支的标记 |
| **分支名** | Branch Name | - | Follow/Left/Right/Straight |
| **S** | Steer | -1.0 到 +1.0 | 转向值，+表示右转 |
| **T** | Throttle | 0.0 到 1.0 | 油门值 |
| **B** | Brake | 0.0 到 1.0 | 刹车值 |

#### 分支对比分析

**用途1：验证分支选择正确性**
- 当前分支的输出应该与场景匹配
- 例如：左转场景下，Left 分支的 S 值应该为负

**用途2：分析分支间差异**
- 不同分支对同一场景的响应差异
- 差异大 → 模型正确学习了分支特定行为
- 差异小 → 模型可能没有充分利用分支信息

**用途3：调试异常行为**
- 如果当前分支输出异常，检查其他分支
- 所有分支都异常 → 可能是输入问题
- 只有当前分支异常 → 可能是分支选择问题

#### 典型场景分析

**场景1：直线道路**
```
>> Follow    S:+0.01  T:0.65  B:0.00
   Left      S:-0.02  T:0.60  B:0.00
   Right     S:+0.03  T:0.58  B:0.00
   Straight  S:+0.00  T:0.62  B:0.00
```
- 所有分支转向值接近0 ✓
- 油门值相近，刹车为0 ✓

**场景2：左转路口**
```
   Follow    S:-0.05  T:0.45  B:0.00
>> Left      S:-0.35  T:0.40  B:0.00
   Right     S:+0.30  T:0.42  B:0.00
   Straight  S:+0.02  T:0.50  B:0.00
```
- Left 分支转向值明显为负（左转）✓
- Right 分支转向值为正（右转）✓
- 分支差异明显 ✓

**场景3：红灯停车**
```
>> Follow    S:+0.01  T:0.00  B:0.85
   Left      S:-0.02  T:0.00  B:0.80
   Right     S:+0.02  T:0.00  B:0.82
   Straight  S:+0.00  T:0.00  B:0.88
```
- 所有分支刹车值都很高 ✓
- 油门为0 ✓
- 红灯响应正确 ✓

---

### 7. 控制历史面板 (Control History Panel)

**位置**：左下 (630-850px)，尺寸 620×220

**面板标题**：`Control History (Recent 100 Frames)`

该面板显示最近100帧的控制信号历史曲线图，用于观察控制信号的时序变化。

#### 曲线说明

| 曲线 | 颜色 | RGB值 | 数据来源 | 范围 |
|------|------|-------|----------|------|
| **Brake** | 红色 | (100, 100, 255) | 刹车预测值 | 0.0 - 1.0 |
| **Throttle** | 绿色 | (100, 230, 100) | 油门预测值 | 0.0 - 1.0 |
| **Speed** | 橙色 | (255, 170, 100) | 归一化速度 | 0.0 - 1.0 |

#### 图表布局

```
1.0 ┬─────────────────────────────────────────────────
    │     ╭─╮                    ╭──╮
0.8 ┤    ╱   ╲                  ╱    ╲    ← Brake 峰值
    │   ╱     ╲                ╱      ╲
0.6 ┤──╱───────╲──────────────╱────────╲──
    │ ╱         ╲            ╱          ╲
0.4 ┤╱           ╲──────────╱            ╲─── Speed
    │             ╲        ╱
0.2 ┤              ╲──────╱                   ← Throttle
    │
0.0 ┴─────────────────────────────────────────────────
    ← 100帧前                              当前帧 →
```

#### 典型模式分析

**模式1：正常行驶**
- Speed 曲线平稳
- Throttle 有轻微波动
- Brake 接近0

**模式2：减速停车**
- Speed 逐渐下降
- Throttle 降为0
- Brake 逐渐上升

**模式3：频繁刹车（可能异常）**
- Brake 曲线频繁出现峰值
- 可能原因：
  - 前方有障碍物
  - 模型刹车预测不稳定
  - 红绿灯频繁变化

**模式4：油门抖动（可能异常）**
- Throttle 曲线高频振荡
- 可能原因：
  - 模型输出不稳定
  - 需要添加平滑后处理

#### 用途

1. **观察控制信号的时序变化**
   - 识别周期性模式
   - 发现异常波动

2. **检测异常的控制模式**
   - 频繁刹车
   - 油门抖动
   - 速度异常

3. **分析模型在不同场景下的响应特性**
   - 直线道路 vs 弯道
   - 空旷道路 vs 拥挤道路
   - 有红绿灯 vs 无红绿灯

---

### 8. 删除/插入曲线面板 (Deletion/Insertion Curves)

**位置**：中下 (630-850px)，尺寸 450×220

**面板标题**：`Deletion/Insertion Curves`

该面板可视化删除和插入曲线，直观展示可解释性方法的质量。

#### 曲线说明

| 曲线 | 颜色 | 含义 |
|------|------|------|
| **Deletion** | 红色 | 按重要性删除像素后的输出变化 |
| **Insertion** | 绿色 | 按重要性插入像素后的输出变化 |

#### 曲线解读

**理想曲线形状**：

```
输出值
  ↑
1.0├────╮                    ╭────── Insertion（快速上升）
   │     ╲                  ╱
0.8├      ╲                ╱
   │       ╲              ╱
0.6├        ╲            ╱
   │         ╲          ╱
0.4├          ╲        ╱
   │           ╲      ╱
0.2├            ╲    ╱
   │             ╲  ╱
0.0├──────────────╲╱─────────── Deletion（快速下降）
   └──────────────────────────→ 删除/插入比例
   0%           50%          100%
```

**曲线形状含义**：

| 形状特征 | 含义 |
|----------|------|
| Deletion 快速下降 | 显著性图准确识别了重要区域 |
| Deletion 缓慢下降 | 显著性图可能不准确 |
| Insertion 快速上升 | 显著性图准确识别了重要区域 |
| Insertion 缓慢上升 | 显著性图可能不准确 |
| 两曲线交叉点靠左 | 可解释性方法质量高 |
| 两曲线交叉点靠右 | 可解释性方法质量低 |

#### AUC 值显示

面板右上角显示两个 AUC 值：
- `Del AUC: 0.xxx` - 删除曲线下面积
- `Ins AUC: 0.xxx` - 插入曲线下面积

#### 参考文献

> Petsiuk et al., "RISE: Randomized Input Sampling for Explanation of Black-box Models", BMVC 2018

---

### 9. 刹车统计面板 (Brake Statistics)

**位置**：右下 (630-850px)，尺寸 380×220

**面板标题**：`Brake Statistics`

该面板显示刹车行为的统计信息，用于评估模型的刹车决策质量。

#### 统计指标

| 指标 | 说明 | 计算方式 |
|------|------|----------|
| **Total Frames** | 总分析帧数 | 累计计数 |
| **Brake > 0.1** | 轻度刹车帧占比 | `count(brake > 0.1) / total` |
| **Hard Brake > 0.5** | 急刹车帧占比 | `count(brake > 0.5) / total` |
| **Avg Brake** | 平均刹车值 | `mean(brake_history)` |
| **Max Brake** | 最大刹车值 | `max(brake_history)` |
| **Brake Std** | 刹车值标准差 | `std(brake_history)` |

#### 指标解读

**Brake > 0.1（轻度刹车比例）**：
| 值范围 | 含义 | 可能原因 |
|--------|------|----------|
| < 5% | 很少刹车 | 道路畅通，或刹车不足 |
| 5% - 15% | 正常 | 正常驾驶 |
| 15% - 30% | 较多刹车 | 交通拥挤，或过度刹车 |
| > 30% | 频繁刹车 | 可能存在问题 |

**Hard Brake > 0.5（急刹车比例）**：
| 值范围 | 含义 | 可能原因 |
|--------|------|----------|
| < 1% | 极少急刹 | 正常，驾驶平稳 |
| 1% - 5% | 偶尔急刹 | 正常，可能遇到紧急情况 |
| 5% - 10% | 较多急刹 | 需要关注，可能过度反应 |
| > 10% | 频繁急刹 | 异常，需要调查原因 |

**Avg Brake（平均刹车值）**：
| 值范围 | 含义 |
|--------|------|
| < 0.05 | 很低，正常行驶 |
| 0.05 - 0.15 | 中等，有一定刹车需求 |
| > 0.15 | 较高，刹车频繁 |

**Brake Std（刹车标准差）**：
| 值范围 | 含义 |
|--------|------|
| < 0.1 | 刹车行为稳定 |
| 0.1 - 0.2 | 刹车行为有一定波动 |
| > 0.2 | 刹车行为波动大，可能不稳定 |

#### 用途

1. **评估模型的刹车行为是否合理**
   - 与人类驾驶员对比
   - 与其他模型对比

2. **检测过度刹车或刹车不足的问题**
   - 过度刹车：Brake > 0.1 比例过高
   - 刹车不足：红灯场景下 Avg Brake 过低

3. **分析红绿灯场景下的刹车响应**
   - 红灯时应该有高刹车值
   - 绿灯时刹车应该较低

---

### 10. 红绿灯状态面板 (Traffic Light Status)

**位置**：最右下 (630-850px)，尺寸 395×220

**面板标题**：`Traffic Light Status`

该面板显示 CARLA 仿真环境中车辆附近最近红绿灯的状态。

#### 显示内容

**状态指示灯**：
- 圆形指示灯显示当前红绿灯状态
- 颜色与实际红绿灯一致

| 状态 | 颜色 | RGB值 |
|------|------|-------|
| Red | 红色 | (60, 60, 255) |
| Yellow | 黄色 | (60, 230, 230) |
| Green | 绿色 | (60, 200, 60) |
| Unknown | 灰色 | (100, 100, 100) |

**距离显示**：
- 显示到最近红绿灯的距离（米）
- 只显示50米范围内的红绿灯
- 超出范围显示 "No traffic light within 50m"

**警告信息**：
- 如果红灯时刹车值过低（< 0.3），显示警告
- 警告文字：`WARNING: LOW BRAKE!`
- 警告颜色：红色背景

#### 红绿灯响应分析

**正确响应**：
| 红绿灯状态 | 距离 | 期望刹车值 |
|------------|------|------------|
| Green | 任意 | 低（< 0.1） |
| Yellow | > 20m | 中（0.1 - 0.3） |
| Yellow | < 20m | 高（> 0.3） |
| Red | > 30m | 中（0.1 - 0.3） |
| Red | < 30m | 高（> 0.5） |
| Red | < 10m | 很高（> 0.7） |

**异常响应**：
- 红灯 + 近距离 + 低刹车 → 模型可能没有正确识别红灯
- 绿灯 + 高刹车 → 模型可能误判，或有其他障碍物

#### 用途

1. **监控模型对红绿灯的响应**
   - 验证模型是否正确识别红绿灯
   - 检查刹车响应是否及时

2. **验证模型是否在红灯时正确刹车**
   - 红灯时刹车值应该较高
   - 距离越近，刹车值应该越高

3. **诊断红绿灯场景下的问题**
   - 如果频繁出现警告，需要检查模型
   - 可能需要更多红绿灯场景的训练数据

---

### 11. 底部信息栏 (Footer)

**位置**：底部 (1030-1080px)

底部信息栏显示使用的方法、参考文献和当前分析状态。

#### 显示内容

**Methods（使用的方法）**：
```
Methods: Grad-CAM++ (Multi-Layer) | Occlusion Sensitivity | Integrated Gradients | Deletion/Insertion Curves
```

**References（参考文献）**：
```
Refs: Chattopadhay WACV'18 | Zeiler ECCV'14 | Sundararajan ICML'17 | Petsiuk BMVC'18
```

**Analysis Status（分析状态）**：
| 状态 | 颜色 | 含义 |
|------|------|------|
| `[FULL ANALYSIS]` | 绿色 | 完整分析模式，所有定量指标都在计算 |
| `[Quick Analysis]` | 灰色 | 快速分析模式，只计算热力图 |

---

## 快捷键

| 按键 | 功能 | 说明 |
|------|------|------|
| `i` | 切换可解释性窗口显示/隐藏 | 隐藏后可减少计算开销 |
| `s` | 手动保存当前帧 | 保存到 `interpret_save_dir` 目录 |
| `p` | 打印刹车统计信息到控制台 | 输出详细的刹车统计数据 |

### 快捷键使用场景

**`i` 键 - 切换显示**：
- 当需要专注于驾驶观察时，可以隐藏仪表板
- 隐藏后可以减少 GPU 计算开销
- 再次按 `i` 可以重新显示

**`s` 键 - 手动保存**：
- 发现有趣的场景时，手动保存当前帧
- 保存的文件命名格式：`interp_XXXXXX.png`
- 保存路径由 `interpret_save_dir` 参数指定

**`p` 键 - 打印统计**：
- 在控制台输出详细的刹车统计信息
- 包括所有统计指标的当前值
- 用于快速检查模型行为

---

## 技术参考

### 使用的可解释性方法

#### 1. Grad-CAM++ (Chattopadhay et al., WACV 2018)

**论文标题**：Grad-CAM++: Generalized Gradient-based Visual Explanations for Deep Convolutional Networks

**核心改进**：
- 改进的梯度加权类激活映射
- 对多目标场景更准确
- 使用二阶梯度信息

**适用场景**：
- 图像分类
- 目标检测
- 自动驾驶决策分析

**优点**：
- 计算速度快（单次前向+反向传播）
- 可视化效果直观
- 支持任意卷积层

**缺点**：
- 分辨率受限于特征图尺寸
- 可能存在梯度消失问题
- 对某些网络结构效果不佳

---

#### 2. Occlusion Sensitivity (Zeiler & Fergus, ECCV 2014)

**论文标题**：Visualizing and Understanding Convolutional Networks

**核心思想**：
- 系统性遮挡分析
- 直接测量区域重要性
- 不依赖梯度信息

**适用场景**：
- 需要定量重要性度量
- 验证其他方法的结果
- 分析模型对局部特征的依赖

**优点**：
- 结果直观易懂
- 不依赖模型内部结构
- 提供定量指标

**缺点**：
- 计算开销大（需要多次前向传播）
- 遮挡块大小影响结果
- 可能遗漏跨区域的特征

---

#### 3. Integrated Gradients (Sundararajan et al., ICML 2017)

**论文标题**：Axiomatic Attribution for Deep Networks

**核心思想**：
- 满足公理化要求的归因方法
- 沿路径积分梯度
- 提供严谨的特征重要性分析

**公理化特性**：
1. **完整性**：归因值之和等于输出差值
2. **敏感性**：影响输出的特征归因非零
3. **实现不变性**：功能相同的模型产生相同归因

**适用场景**：
- 学术研究
- 需要理论保证的场景
- 验证其他方法的准确性

**优点**：
- 理论基础扎实
- 满足重要公理
- 结果可解释性强

**缺点**：
- 计算开销较大
- 需要选择合适的基线
- 积分步数影响精度

---

#### 4. Deletion/Insertion Curves (Petsiuk et al., BMVC 2018)

**论文标题**：RISE: Randomized Input Sampling for Explanation of Black-box Models

**核心思想**：
- 评估解释质量的标准指标
- 通过删除/插入像素测量解释准确性
- 提供定量的评估分数

**适用场景**：
- 评估可解释性方法的质量
- 比较不同方法的效果
- 学术论文中的定量评估

**优点**：
- 提供客观的评估指标
- 可以比较不同方法
- 结果易于理解

**缺点**：
- 计算开销大
- 结果受删除/插入顺序影响
- 可能不适用于所有场景

---

### 模型架构

#### 输入规格

| 参数 | 值 | 说明 |
|------|-----|------|
| 图像尺寸 | 88×200 | 高×宽（像素） |
| 颜色空间 | RGB | 3通道 |
| 速度输入 | 1维 | 归一化速度（0-1） |
| 归一化基准 | 25 km/h | 速度归一化参考值 |

#### 输出规格

| 参数 | 值 | 说明 |
|------|-----|------|
| 总输出数 | 12 | 4分支 × 3控制 |
| 分支数 | 4 | Follow, Left, Right, Straight |
| 控制数 | 3 | Steer, Throttle, Brake |

#### 输出索引映射

```
输出索引 = 分支索引 × 3 + 控制索引

分支索引: Follow=0, Left=1, Right=2, Straight=3
控制索引: Steer=0, Throttle=1, Brake=2

示例:
- Follow 的 Brake: 0 × 3 + 2 = 2
- Left 的 Steer: 1 × 3 + 0 = 3
- Right 的 Throttle: 2 × 3 + 1 = 7
- Straight 的 Brake: 3 × 3 + 2 = 11
```

#### 网络结构概览

```
输入层
  ├── 图像输入 (3, 88, 200)
  └── 速度输入 (1,)
      ↓
卷积块 (conv_block)
  ├── Conv2D + ReLU (Layer 1-2)
  ├── Conv2D + ReLU (Layer 3-4)  ← Grad-CAM++ Layer 4 (17×45)
  ├── Conv2D + ReLU (Layer 5-6)  ← Grad-CAM++ Layer 6 (6×20)
  └── Conv2D + ReLU (Layer 7-8)  ← Grad-CAM++ Layer 8 (2×16)
      ↓
全连接层
  ├── FC + ReLU
  ├── 速度融合
  └── FC + ReLU
      ↓
分支输出层
  ├── Branch 0 (Follow): [Steer, Throttle, Brake]
  ├── Branch 1 (Left): [Steer, Throttle, Brake]
  ├── Branch 2 (Right): [Steer, Throttle, Brake]
  └── Branch 3 (Straight): [Steer, Throttle, Brake]
```

#### 详细网络结构示意图

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                    CarlaNet 网络架构                                      │
├─────────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                         │
│  ┌─────────────────┐     ┌─────────────────┐                                            │
│  │   Image Input   │     │   Speed Input   │                                            │
│  │  (3, 88, 200)   │     │      (1,)       │                                            │
│  └────────┬────────┘     └────────┬────────┘                                            │
│           │                       │                                                     │
│           ▼                       │                                                     │
│  ┌────────────────────────────────┼─────────────────────────────────────────────────┐   │
│  │              CONV_BLOCK        │                                                 │   │
│  │  ┌─────────────────────────────┼───────────────────────────────────────────────┐ │   │
│  │  │ Layer 1: Conv2d(3→32, k=5, s=2) + BN + ReLU                                 │ │   │
│  │  │          Output: (32, 42, 98)                                               │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 2: Conv2d(32→32, k=3, s=1) + BN + ReLU                                │ │   │
│  │  │          Output: (32, 40, 96)                                               │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 3: Conv2d(32→64, k=3, s=2) + BN + ReLU                                │ │   │
│  │  │          Output: (64, 19, 47)                                               │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 4: Conv2d(64→64, k=3, s=1) + BN + ReLU      ◄── Grad-CAM++ Layer 4    │ │   │
│  │  │          Output: (64, 17, 45)                          (高分辨率特征)        │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 5: Conv2d(64→128, k=3, s=2) + BN + ReLU                               │ │   │
│  │  │          Output: (128, 8, 22)                                               │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 6: Conv2d(128→128, k=3, s=1) + BN + ReLU    ◄── Grad-CAM++ Layer 6    │ │   │
│  │  │          Output: (128, 6, 20)                          (推荐分析层)          │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 7: Conv2d(128→256, k=3, s=1) + BN + ReLU                              │ │   │
│  │  │          Output: (256, 4, 18)                                               │ │   │
│  │  ├─────────────────────────────────────────────────────────────────────────────┤ │   │
│  │  │ Layer 8: Conv2d(256→256, k=3, s=1) + BN + ReLU    ◄── Grad-CAM++ Layer 8    │ │   │
│  │  │          Output: (256, 2, 16)                          (高语义特征)          │ │   │
│  │  └─────────────────────────────────────────────────────────────────────────────┘ │   │
│  └──────────────────────────────────────────────────────────────────────────────────┘   │
│           │                       │                                                     │
│           ▼                       │                                                     │
│  ┌─────────────────┐              │                                                     │
│  │    Flatten      │              │                                                     │
│  │ (256×2×16=8192) │              │                                                     │
│  └────────┬────────┘              │                                                     │
│           │                       │                                                     │
│           ▼                       ▼                                                     │
│  ┌─────────────────┐     ┌─────────────────┐                                            │
│  │    IMG_FC       │     │    SPEED_FC     │                                            │
│  │ ┌─────────────┐ │     │ ┌─────────────┐ │                                            │
│  │ │ Linear 8192 │ │     │ │ Linear 1    │ │                                            │
│  │ │    → 512    │ │     │ │   → 128     │ │                                            │
│  │ │ Dropout 0.3 │ │     │ │ Dropout 0.5 │ │                                            │
│  │ │    ReLU     │ │     │ │    ReLU     │ │                                            │
│  │ ├─────────────┤ │     │ ├─────────────┤ │                                            │
│  │ │ Linear 512  │ │     │ │ Linear 128  │ │                                            │
│  │ │    → 512    │ │     │ │   → 128     │ │                                            │
│  │ │ Dropout 0.3 │ │     │ │ Dropout 0.5 │ │                                            │
│  │ │    ReLU     │ │     │ │    ReLU     │ │                                            │
│  │ └─────────────┘ │     │ └─────────────┘ │                                            │
│  │  Output: (512)  │     │  Output: (128)  │                                            │
│  └────────┬────────┘     └────────┬────────┘                                            │
│           │                       │                                                     │
│           └───────────┬───────────┘                                                     │
│                       ▼                                                                 │
│              ┌─────────────────┐                                                        │
│              │   Concatenate   │                                                        │
│              │   (512 + 128)   │                                                        │
│              │    = (640)      │                                                        │
│              └────────┬────────┘                                                        │
│                       │                                                                 │
│                       ▼                                                                 │
│              ┌─────────────────┐                                                        │
│              │     EMB_FC      │                                                        │
│              │ ┌─────────────┐ │                                                        │
│              │ │ Linear 640  │ │                                                        │
│              │ │    → 512    │ │                                                        │
│              │ │ Dropout 0.5 │ │                                                        │
│              │ │    ReLU     │ │                                                        │
│              │ └─────────────┘ │                                                        │
│              │  Output: (512)  │                                                        │
│              └────────┬────────┘                                                        │
│                       │                                                                 │
│     ┌─────────────────┼─────────────────┬─────────────────┬─────────────────┐           │
│     │                 │                 │                 │                 │           │
│     ▼                 ▼                 ▼                 ▼                 ▼           │
│ ┌─────────┐     ┌─────────┐       ┌─────────┐       ┌─────────┐       ┌─────────┐       │
│ │ Branch0 │     │ Branch1 │       │ Branch2 │       │ Branch3 │       │  Speed  │       │
│ │ Follow  │     │  Left   │       │  Right  │       │Straight │       │ Branch  │       │
│ ├─────────┤     ├─────────┤       ├─────────┤       ├─────────┤       ├─────────┤       │
│ │ 512→256 │     │ 512→256 │       │ 512→256 │       │ 512→256 │       │ 512→256 │       │
│ │Drop 0.5 │     │Drop 0.5 │       │Drop 0.5 │       │Drop 0.5 │       │Drop 0.5 │       │
│ │  ReLU   │     │  ReLU   │       │  ReLU   │       │  ReLU   │       │  ReLU   │       │
│ │ 256→256 │     │ 256→256 │       │ 256→256 │       │ 256→256 │       │ 256→256 │       │
│ │  ReLU   │     │  ReLU   │       │  ReLU   │       │  ReLU   │       │  ReLU   │       │
│ │ 256→3   │     │ 256→3   │       │ 256→3   │       │ 256→3   │       │ 256→1   │       │
│ └────┬────┘     └────┬────┘       └────┬────┘       └────┬────┘       └────┬────┘       │
│      │               │                 │                 │                 │           │
│      ▼               ▼                 ▼                 ▼                 ▼           │
│ ┌─────────┐     ┌─────────┐       ┌─────────┐       ┌─────────┐       ┌─────────┐       │
│ │ [S,T,B] │     │ [S,T,B] │       │ [S,T,B] │       │ [S,T,B] │       │  Speed  │       │
│ │  (3,)   │     │  (3,)   │       │  (3,)   │       │  (3,)   │       │  (1,)   │       │
│ └─────────┘     └─────────┘       └─────────┘       └─────────┘       └─────────┘       │
│      │               │                 │                 │                              │
│      └───────────────┴─────────────────┴─────────────────┘                              │
│                                  │                                                      │
│                                  ▼                                                      │
│                         ┌───────────────┐                                               │
│                         │ Control Output│                                               │
│                         │     (12,)     │                                               │
│                         │ [S0,T0,B0,    │                                               │
│                         │  S1,T1,B1,    │                                               │
│                         │  S2,T2,B2,    │                                               │
│                         │  S3,T3,B3]    │                                               │
│                         └───────────────┘                                               │
│                                                                                         │
└─────────────────────────────────────────────────────────────────────────────────────────┘

图例说明:
  S = Steer (转向)    T = Throttle (油门)    B = Brake (刹车)
  k = kernel_size     s = stride             BN = BatchNorm2d
```

#### 卷积层特征图尺寸变化

下表详细展示了输入图像经过每个卷积层后的特征图尺寸变化：

| 层序号 | 层类型 | 输入尺寸 (C, H, W) | 输出尺寸 (C, H, W) | 参数 | Grad-CAM++ 标记 |
|--------|--------|-------------------|-------------------|------|-----------------|
| 输入 | - | (3, 88, 200) | - | - | - |
| 1 | Conv2d + BN + ReLU | (3, 88, 200) | (32, 42, 98) | k=5, s=2 | - |
| 2 | Conv2d + BN + ReLU | (32, 42, 98) | (32, 40, 96) | k=3, s=1 | - |
| 3 | Conv2d + BN + ReLU | (32, 40, 96) | (64, 19, 47) | k=3, s=2 | - |
| 4 | Conv2d + BN + ReLU | (64, 19, 47) | (64, 17, 45) | k=3, s=1 | **Layer 4** (高分辨率) |
| 5 | Conv2d + BN + ReLU | (64, 17, 45) | (128, 8, 22) | k=3, s=2 | - |
| 6 | Conv2d + BN + ReLU | (128, 8, 22) | (128, 6, 20) | k=3, s=1 | **Layer 6** (推荐) |
| 7 | Conv2d + BN + ReLU | (128, 6, 20) | (256, 4, 18) | k=3, s=1 | - |
| 8 | Conv2d + BN + ReLU | (256, 4, 18) | (256, 2, 16) | k=3, s=1 | **Layer 8** (高语义) |

**尺寸计算公式**：
$$H_{out} = \lfloor \frac{H_{in} - k + 2p}{s} \rfloor + 1$$

其中：$k$ = kernel_size, $s$ = stride, $p$ = padding (本网络中 padding=0)

#### 网络参数统计

| 模块 | 参数量 | 占比 |
|------|--------|------|
| conv_block | ~1.2M | 约 60% |
| img_fc | ~4.5M | 约 22% |
| speed_fc | ~17K | < 1% |
| emb_fc | ~328K | 约 2% |
| control_branches (×4) | ~660K | 约 3% |
| speed_branch | ~165K | < 1% |
| **总计** | **~6.9M** | **100%** |

#### 数据流示意图

```
                              ┌──────────────────────────────────────┐
                              │           前向传播数据流               │
                              └──────────────────────────────────────┘

    ┌─────────────┐                                      ┌─────────────┐
    │ RGB Image   │                                      │   Speed     │
    │ (3,88,200)  │                                      │    (1,)     │
    └──────┬──────┘                                      └──────┬──────┘
           │                                                    │
           │  ┌────────────────────────────────────────────┐    │
           │  │              特征提取阶段                    │    │
           │  │  ┌──────────────────────────────────────┐  │    │
           │  │  │ 8层卷积 + BatchNorm + ReLU           │  │    │
           ▼  │  │                                      │  │    │
    ┌──────────┐ │ │  (3,88,200) ──────────► (256,2,16) │  │    │
    │ Conv     │ │ │                                      │  │    │
    │ Block    │ │ │  感受野逐层增大，语义信息逐层丰富     │  │    │
    └──────────┘ │ └──────────────────────────────────────┘  │    │
           │     └────────────────────────────────────────────┘    │
           │                                                       │
           │  ┌────────────────────────────────────────────┐       │
           │  │              特征融合阶段                    │       │
           ▼  │                                            │       ▼
    ┌──────────┐                                      ┌──────────┐
    │ Flatten  │                                      │ Speed FC │
    │  8192    │                                      │  1→128   │
    └────┬─────┘                                      └────┬─────┘
         │                                                 │
         ▼                                                 │
    ┌──────────┐                                           │
    │ Img FC   │                                           │
    │8192→512  │                                           │
    └────┬─────┘                                           │
         │                                                 │
         └─────────────────┬───────────────────────────────┘
                           │
                           ▼
                    ┌─────────────┐
                    │ Concatenate │
                    │  512 + 128  │
                    │   = 640     │
                    └──────┬──────┘
                           │
                           ▼
                    ┌─────────────┐
                    │   Emb FC    │
                    │  640 → 512  │
                    └──────┬──────┘
                           │
           ┌───────────────┼───────────────┬───────────────┬───────────────┐
           │               │               │               │               │
           │  ┌────────────┼───────────────┼───────────────┼────────────┐  │
           │  │            │    条件分支选择阶段            │            │  │
           ▼  │            ▼               ▼               ▼            │  ▼
    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
    │ Branch 0 │    │ Branch 1 │    │ Branch 2 │    │ Branch 3 │    │  Speed   │
    │  Follow  │    │   Left   │    │  Right   │    │ Straight │    │  Branch  │
    │ 512→3    │    │ 512→3    │    │ 512→3    │    │ 512→3    │    │ 512→1    │
    └────┬─────┘    └────┬─────┘    └────┬─────┘    └────┬─────┘    └────┬─────┘
         │               │               │               │               │
         ▼               ▼               ▼               ▼               ▼
    [S₀,T₀,B₀]     [S₁,T₁,B₁]     [S₂,T₂,B₂]     [S₃,T₃,B₃]        [Speed]
         │               │               │               │
         └───────────────┴───────────────┴───────────────┘
                                   │
                                   ▼
                         ┌─────────────────┐
                         │  Control Output │
                         │      (12,)      │
                         └─────────────────┘
                                   │
                                   ▼
                    ┌──────────────────────────────┐
                    │      根据导航命令选择分支      │
                    │  nav_cmd: 2=Follow, 3=Left,  │
                    │          4=Right, 5=Straight │
                    │  branch_idx = nav_cmd - 2    │
                    └──────────────────────────────┘
                                   │
                                   ▼
                    ┌──────────────────────────────┐
                    │     最终控制输出 (3,)         │
                    │  [Steer, Throttle, Brake]    │
                    └──────────────────────────────┘
```

#### Grad-CAM++ 分析层选择说明

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       Grad-CAM++ 目标层选择指南                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Layer 4 (64, 17, 45)                                                       │
│  ├── 特点: 高空间分辨率，低语义信息                                           │
│  ├── 适用: 需要精确定位关注区域时                                             │
│  ├── 优点: 热力图细节丰富，边界清晰                                           │
│  └── 缺点: 可能包含较多噪声，语义解释性较弱                                    │
│                                                                             │
│  Layer 6 (128, 6, 20)  ★ 推荐                                               │
│  ├── 特点: 平衡空间分辨率和语义信息                                           │
│  ├── 适用: 大多数分析场景                                                    │
│  ├── 优点: 热力图清晰且有意义，计算开销适中                                    │
│  └── 缺点: 无明显缺点                                                        │
│                                                                             │
│  Layer 8 (256, 2, 16)                                                       │
│  ├── 特点: 低空间分辨率，高语义信息                                           │
│  ├── 适用: 分析模型关注的高层语义特征                                         │
│  ├── 优点: 语义解释性强，噪声少                                               │
│  └── 缺点: 空间定位精度低，热力图较为粗糙                                      │
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │                    分辨率 vs 语义信息 权衡曲线                        │    │
│  │                                                                     │    │
│  │  语义信息 ▲                                                         │    │
│  │          │                                    ● Layer 8             │    │
│  │          │                                   ╱                      │    │
│  │          │                                  ╱                       │    │
│  │          │                    ● Layer 6    ╱                        │    │
│  │          │                   ╱            ╱                         │    │
│  │          │                  ╱            ╱                          │    │
│  │          │     ● Layer 4   ╱            ╱                           │    │
│  │          │    ╱           ╱            ╱                            │    │
│  │          │   ╱           ╱            ╱                             │    │
│  │          └──┴───────────┴────────────┴──────────────► 空间分辨率     │    │
│  │             高                                    低                │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### 相关文件

| 文件 | 说明 | 主要功能 |
|------|------|----------|
| `carla_interpretability.py` | 可解释性分析和仪表板渲染 | GradCAM, 遮挡分析, 积分梯度, 仪表板渲染 |
| `carla_inference.py` | 主推理循环和仪表板集成 | 模型推理, 传感器管理, 可视化集成 |
| `carla_model_predictor.py` | 模型预测和分支输出 | 预测控制值, 分支选择 |
| `carla_config.py` | 配置参数 | 图像尺寸, 速度归一化, 显示参数 |
| `carla_image_processor.py` | 图像预处理 | 裁剪, 缩放, 归一化 |
| `carla_vehicle_controller.py` | 车辆控制 | 应用控制信号, 速度获取 |

---

## 常见问题

### Q1: 热力图显示 "Waiting..." 怎么办？

**原因**：
- 遮挡敏感性和积分梯度需要多次前向传播，计算较慢
- 第一帧可能还没有完成计算

**解决方案**：
1. 等待几帧，计算完成后会自动显示
2. 如果持续显示 "Waiting..."，检查 GPU 是否正常工作
3. 可以降低分析参数（如减少 `ig_steps`）来加速计算

---

### Q2: 为什么不同层的热力图分辨率不同？

**原因**：
卷积神经网络的不同层有不同的特征图尺寸：
- 浅层：保留更多空间信息，分辨率高
- 深层：包含更多语义信息，分辨率低

**各层分辨率**：
| 层 | 特征图尺寸 | 上采样倍数 |
|----|------------|------------|
| Layer 4 | 17×45 | ~5× |
| Layer 6 | 6×20 | ~15× |
| Layer 8 | 2×16 | ~44× |

**建议**：
- 使用 Layer 6 作为默认分析层（平衡分辨率和语义）
- 需要精细定位时使用 Layer 4
- 需要高层语义时使用 Layer 8

---

### Q3: Combined Score 为负值正常吗？

**可能原因**：
1. 可解释性方法没有准确识别模型关注的区域
2. 模型的决策过程比较复杂，不依赖局部特征
3. 当前帧的输出值接近0，导致计算不稳定

**解决方案**：
1. 检查其他帧的 Combined Score，看是否是个别现象
2. 查看热力图是否合理
3. 如果持续为负，可能需要调整分析参数

**正常范围**：
- 大多数帧应该在 0.1 - 0.6 之间
- 偶尔为负是正常的
- 持续为负需要调查

---

### Q4: 如何保存分析结果？

**自动保存**：
1. 设置 `interpret_save_dir` 参数指定保存目录
2. 设置 `interpret_save_interval` 参数指定保存频率（每N帧保存一次）
3. 仪表板会自动保存为 PNG 图像

**手动保存**：
1. 按 `s` 键手动保存当前帧
2. 保存路径：`{interpret_save_dir}/interp_XXXXXX.png`

**导出定量指标**：
```python
# 在代码中调用
interp_visualizer.export_metrics('metrics.json')
```

---

### Q5: 如何调整分析参数？

**在 `carla_inference.py` 中创建可解释性分析器时设置**：

```python
self.interp_visualizer = create_interpretability_visualizer(
    model, self.device, self.interpret_save_dir,
    full_analysis=True,  # 启用完整分析
    # 以下参数可以调整
    occlusion_patch_size=16,  # 遮挡块大小
    occlusion_stride=8,       # 遮挡步长
    ig_steps=30,              # 积分梯度步数
    di_steps=15,              # 删除/插入步数
    grad_cam_layer_index=-3,  # Grad-CAM 目标层
)
```

**参数调整建议**：

| 参数 | 默认值 | 调整建议 |
|------|--------|----------|
| `occlusion_patch_size` | 16 | 增大可加速，减小可提高精度 |
| `occlusion_stride` | 8 | 增大可加速，减小可提高精度 |
| `ig_steps` | 30 | 增大可提高精度，减小可加速 |
| `di_steps` | 15 | 增大可提高精度，减小可加速 |
| `grad_cam_layer_index` | -3 | -1=最后层, -3=推荐, -5=高分辨率 |

---

### Q6: 仪表板卡顿怎么办？

**可能原因**：
1. GPU 计算能力不足
2. 分析参数设置过高
3. 其他程序占用 GPU 资源

**解决方案**：

1. **降低分析频率**：
   ```python
   self.analysis_interval = 5  # 每5帧执行一次完整分析
   ```

2. **减少分析方法**：
   ```python
   enable_occlusion=False,  # 禁用遮挡敏感性
   enable_integrated_gradients=False,  # 禁用积分梯度
   ```

3. **降低分析参数**：
   ```python
   occlusion_patch_size=24,  # 增大遮挡块
   occlusion_stride=16,      # 增大步长
   ig_steps=20,              # 减少积分步数
   ```

4. **使用快速分析模式**：
   ```python
   full_analysis=False  # 只计算热力图
   ```

---

### Q7: 如何解读热力图与控制输出的关系？

**基本原则**：
- 热力图显示模型"关注"的区域
- 关注区域应该与控制决策相关

**典型对应关系**：

| 控制输出 | 期望关注区域 |
|----------|--------------|
| 高刹车 | 前方障碍物、红绿灯、停止线 |
| 高油门 | 道路中央、远处开阔区域 |
| 左转向 | 道路左侧边缘、左转车道标记 |
| 右转向 | 道路右侧边缘、右转车道标记 |

**异常情况**：
- 高刹车但热力图关注天空 → 模型可能学习了错误特征
- 转向但热力图关注道路中央 → 模型可能依赖其他特征

---

### Q8: 如何在论文中引用这些方法？

**BibTeX 引用**：

```bibtex
@inproceedings{chattopadhay2018gradcampp,
  title={Grad-CAM++: Generalized Gradient-based Visual Explanations for Deep Convolutional Networks},
  author={Chattopadhay, Aditya and Sarkar, Anirban and Howlader, Prantik and Balasubramanian, Vineeth N},
  booktitle={IEEE Winter Conference on Applications of Computer Vision (WACV)},
  year={2018}
}

@inproceedings{zeiler2014visualizing,
  title={Visualizing and Understanding Convolutional Networks},
  author={Zeiler, Matthew D and Fergus, Rob},
  booktitle={European Conference on Computer Vision (ECCV)},
  year={2014}
}

@inproceedings{sundararajan2017axiomatic,
  title={Axiomatic Attribution for Deep Networks},
  author={Sundararajan, Mukund and Taly, Ankur and Yan, Qiqi},
  booktitle={International Conference on Machine Learning (ICML)},
  year={2017}
}

@inproceedings{petsiuk2018rise,
  title={RISE: Randomized Input Sampling for Explanation of Black-box Models},
  author={Petsiuk, Vitali and Das, Abir and Saenko, Kate},
  booktitle={British Machine Vision Conference (BMVC)},
  year={2018}
}
```

---

## 使用示例

### 基本使用

```python
# 启动带可解释性分析的推理
python carla_inference.py \
    --model_path ./model/best_model.pth \
    --interpret \
    --interpret_save_dir ./interpret_output \
    --interpret_save_interval 10
```

### 命令行参数

| 参数 | 说明 | 默认值 |
|------|------|--------|
| `--interpret` | 启用可解释性分析 | False |
| `--interpret_save_dir` | 保存目录 | None |
| `--interpret_save_interval` | 保存频率（帧） | 10 |

### 代码集成示例

```python
from carla_interpretability import create_interpretability_visualizer

# 创建可解释性分析器
interp_visualizer = create_interpretability_visualizer(
    model=model,
    device=device,
    save_dir='./interpret_output',
    full_analysis=True
)

# 分析单帧
results = interp_visualizer.analyze_frame(
    img_tensor, speed_tensor, original_image,
    control_result, current_command
)

# 渲染仪表板
dashboard = interp_visualizer.render_dashboard(
    original_image, results, control_result,
    current_command, traffic_light_info, all_branch_predictions
)

# 显示仪表板
cv2.imshow('Model Interpretability', dashboard)

# 导出指标
interp_visualizer.export_metrics('metrics.json')
```

---

## 版本历史

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v2.0 | 2025-12 | 1920×1080分辨率，多层级Grad-CAM++，完整定量分析，删除/插入曲线可视化 |
| v1.0 | 2025-11 | 初始版本，基础Grad-CAM可视化 |

### v2.0 主要更新

1. **分辨率提升**：从 800×600 提升到 1920×1080
2. **多层级分析**：支持同时查看多个卷积层的热力图
3. **Grad-CAM++ 支持**：使用改进的梯度加权方法
4. **完整定量分析**：
   - 遮挡敏感性分析
   - 积分梯度归因
   - 删除/插入曲线
5. **学术指标**：提供可直接用于论文的定量指标
6. **改进的可视化**：更清晰的布局和颜色编码

---

## 附录

### A. 颜色映射参考

#### JET 色图（用于 Grad-CAM++）
```
低 ←─────────────────────────────────────→ 高
蓝色 → 青色 → 绿色 → 黄色 → 红色
```

#### HOT 色图（用于遮挡敏感性）
```
低 ←─────────────────────────────────────→ 高
黑色 → 红色 → 橙色 → 黄色 → 白色
```

#### VIRIDIS 色图（用于积分梯度）
```
低 ←─────────────────────────────────────→ 高
深紫色 → 蓝色 → 青色 → 绿色 → 黄色
```

### B. 坐标系统

**图像坐标**：
- 原点：左上角
- X轴：向右为正
- Y轴：向下为正

**转向坐标**：
- 负值：左转
- 正值：右转
- 零值：直行

### C. 性能基准

在 NVIDIA RTX 3080 上的典型性能：

| 分析方法 | 单帧耗时 | 说明 |
|----------|----------|------|
| Grad-CAM++ | ~5ms | 单层分析 |
| 多层 Grad-CAM++ | ~15ms | 3层分析 |
| 遮挡敏感性 | ~100ms | 16×16 块，步长8 |
| 积分梯度 | ~150ms | 30步积分 |
| 删除/插入 | ~80ms | 15步 |
| 完整分析 | ~350ms | 所有方法 |

**优化建议**：
- 如需实时运行，可禁用遮挡敏感性和积分梯度
- 只使用 Grad-CAM++ 可达到 60+ FPS
